///
/// HybridNitroOrbComponent.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#include "HybridNitroOrbComponent.hpp"

#include <string>
#include <exception>
#include <utility>
#include <NitroModules/NitroDefines.hpp>
#include <NitroModules/JSIConverter.hpp>
#include <react/renderer/core/RawValue.h>
#include <react/renderer/core/ShadowNode.h>
#include <react/renderer/core/ComponentDescriptor.h>
#include <react/renderer/components/view/ViewProps.h>

namespace margelo::nitro::nitroorb::views {

  extern const char HybridNitroOrbComponentName[] = "NitroOrb";

  HybridNitroOrbProps::HybridNitroOrbProps(const react::PropsParserContext& context,
                                           const HybridNitroOrbProps& sourceProps,
                                           const react::RawProps& rawProps):
    react::ViewProps(context, sourceProps, rawProps, filterObjectKeys),
    preset([&]() -> CachedProp<std::optional<PresetType>> {
      try {
        const react::RawValue* rawValue = rawProps.at("preset", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.preset;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<PresetType>>::fromRawValue(*runtime, value, sourceProps.preset);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroOrb.preset: ") + exc.what());
      }
    }()),
    speed([&]() -> CachedProp<std::optional<double>> {
      try {
        const react::RawValue* rawValue = rawProps.at("speed", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.speed;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<double>>::fromRawValue(*runtime, value, sourceProps.speed);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroOrb.speed: ") + exc.what());
      }
    }()),
    glowColor([&]() -> CachedProp<std::optional<std::string>> {
      try {
        const react::RawValue* rawValue = rawProps.at("glowColor", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.glowColor;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<std::string>>::fromRawValue(*runtime, value, sourceProps.glowColor);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroOrb.glowColor: ") + exc.what());
      }
    }()),
    backgroundColors([&]() -> CachedProp<std::optional<std::vector<std::string>>> {
      try {
        const react::RawValue* rawValue = rawProps.at("backgroundColors", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.backgroundColors;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<std::vector<std::string>>>::fromRawValue(*runtime, value, sourceProps.backgroundColors);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroOrb.backgroundColors: ") + exc.what());
      }
    }()),
    particleColor([&]() -> CachedProp<std::optional<std::string>> {
      try {
        const react::RawValue* rawValue = rawProps.at("particleColor", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.particleColor;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<std::string>>::fromRawValue(*runtime, value, sourceProps.particleColor);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroOrb.particleColor: ") + exc.what());
      }
    }()),
    showWavyBlobs([&]() -> CachedProp<std::optional<bool>> {
      try {
        const react::RawValue* rawValue = rawProps.at("showWavyBlobs", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.showWavyBlobs;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<bool>>::fromRawValue(*runtime, value, sourceProps.showWavyBlobs);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroOrb.showWavyBlobs: ") + exc.what());
      }
    }()),
    showParticles([&]() -> CachedProp<std::optional<bool>> {
      try {
        const react::RawValue* rawValue = rawProps.at("showParticles", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.showParticles;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<bool>>::fromRawValue(*runtime, value, sourceProps.showParticles);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroOrb.showParticles: ") + exc.what());
      }
    }()),
    showGlowEffects([&]() -> CachedProp<std::optional<bool>> {
      try {
        const react::RawValue* rawValue = rawProps.at("showGlowEffects", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.showGlowEffects;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<bool>>::fromRawValue(*runtime, value, sourceProps.showGlowEffects);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroOrb.showGlowEffects: ") + exc.what());
      }
    }()),
    showShadow([&]() -> CachedProp<std::optional<bool>> {
      try {
        const react::RawValue* rawValue = rawProps.at("showShadow", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.showShadow;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<bool>>::fromRawValue(*runtime, value, sourceProps.showShadow);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroOrb.showShadow: ") + exc.what());
      }
    }()),
    coreGlowItensity([&]() -> CachedProp<std::optional<double>> {
      try {
        const react::RawValue* rawValue = rawProps.at("coreGlowItensity", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.coreGlowItensity;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<double>>::fromRawValue(*runtime, value, sourceProps.coreGlowItensity);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroOrb.coreGlowItensity: ") + exc.what());
      }
    }()),
    hybridRef([&]() -> CachedProp<std::optional<std::function<void(const std::shared_ptr<HybridNitroOrbSpec>& /* ref */)>>> {
      try {
        const react::RawValue* rawValue = rawProps.at("hybridRef", nullptr, nullptr);
        if (rawValue == nullptr) return sourceProps.hybridRef;
        const auto& [runtime, value] = (std::pair<jsi::Runtime*, jsi::Value>)*rawValue;
        return CachedProp<std::optional<std::function<void(const std::shared_ptr<HybridNitroOrbSpec>& /* ref */)>>>::fromRawValue(*runtime, value.asObject(*runtime).getProperty(*runtime, "f"), sourceProps.hybridRef);
      } catch (const std::exception& exc) {
        throw std::runtime_error(std::string("NitroOrb.hybridRef: ") + exc.what());
      }
    }()) { }

  HybridNitroOrbProps::HybridNitroOrbProps(const HybridNitroOrbProps& other):
    react::ViewProps(),
    preset(other.preset),
    speed(other.speed),
    glowColor(other.glowColor),
    backgroundColors(other.backgroundColors),
    particleColor(other.particleColor),
    showWavyBlobs(other.showWavyBlobs),
    showParticles(other.showParticles),
    showGlowEffects(other.showGlowEffects),
    showShadow(other.showShadow),
    coreGlowItensity(other.coreGlowItensity),
    hybridRef(other.hybridRef) { }

  bool HybridNitroOrbProps::filterObjectKeys(const std::string& propName) {
    switch (hashString(propName)) {
      case hashString("preset"): return true;
      case hashString("speed"): return true;
      case hashString("glowColor"): return true;
      case hashString("backgroundColors"): return true;
      case hashString("particleColor"): return true;
      case hashString("showWavyBlobs"): return true;
      case hashString("showParticles"): return true;
      case hashString("showGlowEffects"): return true;
      case hashString("showShadow"): return true;
      case hashString("coreGlowItensity"): return true;
      case hashString("hybridRef"): return true;
      default: return false;
    }
  }

  HybridNitroOrbComponentDescriptor::HybridNitroOrbComponentDescriptor(const react::ComponentDescriptorParameters& parameters)
    : ConcreteComponentDescriptor(parameters,
                                  react::RawPropsParser(/* enableJsiParser */ true)) {}

  std::shared_ptr<const react::Props> HybridNitroOrbComponentDescriptor::cloneProps(const react::PropsParserContext& context,
                                                                                    const std::shared_ptr<const react::Props>& props,
                                                                                    react::RawProps rawProps) const {
    // 1. Prepare raw props parser
    rawProps.parse(rawPropsParser_);
    // 2. Copy props with Nitro's cached copy constructor
    return HybridNitroOrbShadowNode::Props(context, /* & */ rawProps, props);
  }

#ifdef ANDROID
  void HybridNitroOrbComponentDescriptor::adopt(react::ShadowNode& shadowNode) const {
    // This is called immediately after `ShadowNode` is created, cloned or in progress.
    // On Android, we need to wrap props in our state, which gets routed through Java and later unwrapped in JNI/C++.
    auto& concreteShadowNode = dynamic_cast<HybridNitroOrbShadowNode&>(shadowNode);
    const HybridNitroOrbProps& props = concreteShadowNode.getConcreteProps();
    HybridNitroOrbState state;
    state.setProps(props);
    concreteShadowNode.setStateData(std::move(state));
  }
#endif

} // namespace margelo::nitro::nitroorb::views
